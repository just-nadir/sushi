/**
 * Generated by orval v8.0.3 ðŸº
 * Do not edit manually.
 * Sushi API
 * The Sushi Delivery API description
 * OpenAPI spec version: 1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

export interface CreateCategoryDto {
  name: string;
  image?: string;
  sortOrder?: number;
}

export interface UpdateCategoryDto { [key: string]: unknown }

export interface CreateProductDto {
  name: string;
  description?: string;
  price: number;
  image?: string;
  isAvailable?: boolean;
  categoryId: string;
}

export interface UpdateProductDto { [key: string]: unknown }

export interface TelegramLoginDto {
  telegramId: string;
  username?: string;
  fullName?: string;
  phone?: string;
}

export interface CreateUserDto {
  fullName?: string;
  username?: string;
  phone?: string;
  telegramId?: string;
}

export interface UpdateUserDto { [key: string]: unknown }

export interface CreateOrderItemDto {
  productId: string;
  quantity: number;
}

export type CreateOrderDtoType = { [key: string]: unknown };

export interface CreateOrderDto {
  type: CreateOrderDtoType;
  items: CreateOrderItemDto[];
  address?: string;
  locationLat?: number;
  locationLon?: number;
  comment?: string;
  customerName?: string;
  customerPhone?: string;
  paymentType?: string;
  userTelegramId?: string;
}

export interface UpdateOrderDto {
  status?: string;
}

export interface UpdateSettingDto {
  value: string;
}

export type CategoriesControllerFindAll200Item = { [key: string]: unknown };

export type ProductsControllerFindAll200Item = { [key: string]: unknown };

export type AuthControllerVerifyOtp201 = { [key: string]: unknown };

export type OrdersControllerCreate201 = { [key: string]: unknown };

export type OrdersControllerFindAllParams = {
phone: string;
};

export type OrdersControllerFindAll200Item = { [key: string]: unknown };

export type OrdersControllerUpdate200 = { [key: string]: unknown };

export type appControllerGetHelloResponse200 = {
  data: string
  status: 200
}
    
export type appControllerGetHelloResponseSuccess = (appControllerGetHelloResponse200) & {
  headers: Headers;
};
;

export type appControllerGetHelloResponse = (appControllerGetHelloResponseSuccess)

export const getAppControllerGetHelloUrl = () => {


  

  return `/api/`
}

export const appControllerGetHello = async ( options?: RequestInit): Promise<appControllerGetHelloResponse> => {
  
  const res = await fetch(getAppControllerGetHelloUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: appControllerGetHelloResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as appControllerGetHelloResponse
}





export const getAppControllerGetHelloQueryKey = () => {
    return [
    `/api/`
    ] as const;
    }

    
export const getAppControllerGetHelloQueryOptions = <TData = Awaited<ReturnType<typeof appControllerGetHello>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAppControllerGetHelloQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof appControllerGetHello>>> = ({ signal }) => appControllerGetHello({ signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AppControllerGetHelloQueryResult = NonNullable<Awaited<ReturnType<typeof appControllerGetHello>>>
export type AppControllerGetHelloQueryError = unknown


export function useAppControllerGetHello<TData = Awaited<ReturnType<typeof appControllerGetHello>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof appControllerGetHello>>,
          TError,
          Awaited<ReturnType<typeof appControllerGetHello>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAppControllerGetHello<TData = Awaited<ReturnType<typeof appControllerGetHello>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof appControllerGetHello>>,
          TError,
          Awaited<ReturnType<typeof appControllerGetHello>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAppControllerGetHello<TData = Awaited<ReturnType<typeof appControllerGetHello>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useAppControllerGetHello<TData = Awaited<ReturnType<typeof appControllerGetHello>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAppControllerGetHelloQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





export type categoriesControllerCreateResponse201 = {
  data: void
  status: 201
}
    
export type categoriesControllerCreateResponseSuccess = (categoriesControllerCreateResponse201) & {
  headers: Headers;
};
;

export type categoriesControllerCreateResponse = (categoriesControllerCreateResponseSuccess)

export const getCategoriesControllerCreateUrl = () => {


  

  return `/api/categories`
}

export const categoriesControllerCreate = async (createCategoryDto: CreateCategoryDto, options?: RequestInit): Promise<categoriesControllerCreateResponse> => {
  
  const res = await fetch(getCategoriesControllerCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createCategoryDto,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: categoriesControllerCreateResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as categoriesControllerCreateResponse
}




export const getCategoriesControllerCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof categoriesControllerCreate>>, TError,{data: CreateCategoryDto}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof categoriesControllerCreate>>, TError,{data: CreateCategoryDto}, TContext> => {

const mutationKey = ['categoriesControllerCreate'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof categoriesControllerCreate>>, {data: CreateCategoryDto}> = (props) => {
          const {data} = props ?? {};

          return  categoriesControllerCreate(data,fetchOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type CategoriesControllerCreateMutationResult = NonNullable<Awaited<ReturnType<typeof categoriesControllerCreate>>>
    export type CategoriesControllerCreateMutationBody = CreateCategoryDto
    export type CategoriesControllerCreateMutationError = unknown

    export const useCategoriesControllerCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof categoriesControllerCreate>>, TError,{data: CreateCategoryDto}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof categoriesControllerCreate>>,
        TError,
        {data: CreateCategoryDto},
        TContext
      > => {
      return useMutation(getCategoriesControllerCreateMutationOptions(options), queryClient);
    }
    
export type categoriesControllerFindAllResponse200 = {
  data: CategoriesControllerFindAll200Item[]
  status: 200
}
    
export type categoriesControllerFindAllResponseSuccess = (categoriesControllerFindAllResponse200) & {
  headers: Headers;
};
;

export type categoriesControllerFindAllResponse = (categoriesControllerFindAllResponseSuccess)

export const getCategoriesControllerFindAllUrl = () => {


  

  return `/api/categories`
}

export const categoriesControllerFindAll = async ( options?: RequestInit): Promise<categoriesControllerFindAllResponse> => {
  
  const res = await fetch(getCategoriesControllerFindAllUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: categoriesControllerFindAllResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as categoriesControllerFindAllResponse
}





export const getCategoriesControllerFindAllQueryKey = () => {
    return [
    `/api/categories`
    ] as const;
    }

    
export const getCategoriesControllerFindAllQueryOptions = <TData = Awaited<ReturnType<typeof categoriesControllerFindAll>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof categoriesControllerFindAll>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCategoriesControllerFindAllQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof categoriesControllerFindAll>>> = ({ signal }) => categoriesControllerFindAll({ signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof categoriesControllerFindAll>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CategoriesControllerFindAllQueryResult = NonNullable<Awaited<ReturnType<typeof categoriesControllerFindAll>>>
export type CategoriesControllerFindAllQueryError = unknown


export function useCategoriesControllerFindAll<TData = Awaited<ReturnType<typeof categoriesControllerFindAll>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof categoriesControllerFindAll>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof categoriesControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof categoriesControllerFindAll>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCategoriesControllerFindAll<TData = Awaited<ReturnType<typeof categoriesControllerFindAll>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof categoriesControllerFindAll>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof categoriesControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof categoriesControllerFindAll>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCategoriesControllerFindAll<TData = Awaited<ReturnType<typeof categoriesControllerFindAll>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof categoriesControllerFindAll>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useCategoriesControllerFindAll<TData = Awaited<ReturnType<typeof categoriesControllerFindAll>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof categoriesControllerFindAll>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCategoriesControllerFindAllQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





export type categoriesControllerFindOneResponse200 = {
  data: void
  status: 200
}
    
export type categoriesControllerFindOneResponseSuccess = (categoriesControllerFindOneResponse200) & {
  headers: Headers;
};
;

export type categoriesControllerFindOneResponse = (categoriesControllerFindOneResponseSuccess)

export const getCategoriesControllerFindOneUrl = (id: string,) => {


  

  return `/api/categories/${id}`
}

export const categoriesControllerFindOne = async (id: string, options?: RequestInit): Promise<categoriesControllerFindOneResponse> => {
  
  const res = await fetch(getCategoriesControllerFindOneUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: categoriesControllerFindOneResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as categoriesControllerFindOneResponse
}





export const getCategoriesControllerFindOneQueryKey = (id: string,) => {
    return [
    `/api/categories/${id}`
    ] as const;
    }

    
export const getCategoriesControllerFindOneQueryOptions = <TData = Awaited<ReturnType<typeof categoriesControllerFindOne>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof categoriesControllerFindOne>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCategoriesControllerFindOneQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof categoriesControllerFindOne>>> = ({ signal }) => categoriesControllerFindOne(id, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof categoriesControllerFindOne>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CategoriesControllerFindOneQueryResult = NonNullable<Awaited<ReturnType<typeof categoriesControllerFindOne>>>
export type CategoriesControllerFindOneQueryError = unknown


export function useCategoriesControllerFindOne<TData = Awaited<ReturnType<typeof categoriesControllerFindOne>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof categoriesControllerFindOne>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof categoriesControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof categoriesControllerFindOne>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCategoriesControllerFindOne<TData = Awaited<ReturnType<typeof categoriesControllerFindOne>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof categoriesControllerFindOne>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof categoriesControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof categoriesControllerFindOne>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCategoriesControllerFindOne<TData = Awaited<ReturnType<typeof categoriesControllerFindOne>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof categoriesControllerFindOne>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useCategoriesControllerFindOne<TData = Awaited<ReturnType<typeof categoriesControllerFindOne>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof categoriesControllerFindOne>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCategoriesControllerFindOneQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





export type categoriesControllerUpdateResponse200 = {
  data: void
  status: 200
}
    
export type categoriesControllerUpdateResponseSuccess = (categoriesControllerUpdateResponse200) & {
  headers: Headers;
};
;

export type categoriesControllerUpdateResponse = (categoriesControllerUpdateResponseSuccess)

export const getCategoriesControllerUpdateUrl = (id: string,) => {


  

  return `/api/categories/${id}`
}

export const categoriesControllerUpdate = async (id: string,
    updateCategoryDto: UpdateCategoryDto, options?: RequestInit): Promise<categoriesControllerUpdateResponse> => {
  
  const res = await fetch(getCategoriesControllerUpdateUrl(id),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateCategoryDto,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: categoriesControllerUpdateResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as categoriesControllerUpdateResponse
}




export const getCategoriesControllerUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof categoriesControllerUpdate>>, TError,{id: string;data: UpdateCategoryDto}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof categoriesControllerUpdate>>, TError,{id: string;data: UpdateCategoryDto}, TContext> => {

const mutationKey = ['categoriesControllerUpdate'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof categoriesControllerUpdate>>, {id: string;data: UpdateCategoryDto}> = (props) => {
          const {id,data} = props ?? {};

          return  categoriesControllerUpdate(id,data,fetchOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type CategoriesControllerUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof categoriesControllerUpdate>>>
    export type CategoriesControllerUpdateMutationBody = UpdateCategoryDto
    export type CategoriesControllerUpdateMutationError = unknown

    export const useCategoriesControllerUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof categoriesControllerUpdate>>, TError,{id: string;data: UpdateCategoryDto}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof categoriesControllerUpdate>>,
        TError,
        {id: string;data: UpdateCategoryDto},
        TContext
      > => {
      return useMutation(getCategoriesControllerUpdateMutationOptions(options), queryClient);
    }
    
export type categoriesControllerRemoveResponse200 = {
  data: void
  status: 200
}
    
export type categoriesControllerRemoveResponseSuccess = (categoriesControllerRemoveResponse200) & {
  headers: Headers;
};
;

export type categoriesControllerRemoveResponse = (categoriesControllerRemoveResponseSuccess)

export const getCategoriesControllerRemoveUrl = (id: string,) => {


  

  return `/api/categories/${id}`
}

export const categoriesControllerRemove = async (id: string, options?: RequestInit): Promise<categoriesControllerRemoveResponse> => {
  
  const res = await fetch(getCategoriesControllerRemoveUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: categoriesControllerRemoveResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as categoriesControllerRemoveResponse
}




export const getCategoriesControllerRemoveMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof categoriesControllerRemove>>, TError,{id: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof categoriesControllerRemove>>, TError,{id: string}, TContext> => {

const mutationKey = ['categoriesControllerRemove'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof categoriesControllerRemove>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  categoriesControllerRemove(id,fetchOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type CategoriesControllerRemoveMutationResult = NonNullable<Awaited<ReturnType<typeof categoriesControllerRemove>>>
    
    export type CategoriesControllerRemoveMutationError = unknown

    export const useCategoriesControllerRemove = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof categoriesControllerRemove>>, TError,{id: string}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof categoriesControllerRemove>>,
        TError,
        {id: string},
        TContext
      > => {
      return useMutation(getCategoriesControllerRemoveMutationOptions(options), queryClient);
    }
    
export type productsControllerCreateResponse201 = {
  data: void
  status: 201
}
    
export type productsControllerCreateResponseSuccess = (productsControllerCreateResponse201) & {
  headers: Headers;
};
;

export type productsControllerCreateResponse = (productsControllerCreateResponseSuccess)

export const getProductsControllerCreateUrl = () => {


  

  return `/api/products`
}

export const productsControllerCreate = async (createProductDto: CreateProductDto, options?: RequestInit): Promise<productsControllerCreateResponse> => {
  
  const res = await fetch(getProductsControllerCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createProductDto,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: productsControllerCreateResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as productsControllerCreateResponse
}




export const getProductsControllerCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof productsControllerCreate>>, TError,{data: CreateProductDto}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof productsControllerCreate>>, TError,{data: CreateProductDto}, TContext> => {

const mutationKey = ['productsControllerCreate'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof productsControllerCreate>>, {data: CreateProductDto}> = (props) => {
          const {data} = props ?? {};

          return  productsControllerCreate(data,fetchOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type ProductsControllerCreateMutationResult = NonNullable<Awaited<ReturnType<typeof productsControllerCreate>>>
    export type ProductsControllerCreateMutationBody = CreateProductDto
    export type ProductsControllerCreateMutationError = unknown

    export const useProductsControllerCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof productsControllerCreate>>, TError,{data: CreateProductDto}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof productsControllerCreate>>,
        TError,
        {data: CreateProductDto},
        TContext
      > => {
      return useMutation(getProductsControllerCreateMutationOptions(options), queryClient);
    }
    
export type productsControllerFindAllResponse200 = {
  data: ProductsControllerFindAll200Item[]
  status: 200
}
    
export type productsControllerFindAllResponseSuccess = (productsControllerFindAllResponse200) & {
  headers: Headers;
};
;

export type productsControllerFindAllResponse = (productsControllerFindAllResponseSuccess)

export const getProductsControllerFindAllUrl = () => {


  

  return `/api/products`
}

export const productsControllerFindAll = async ( options?: RequestInit): Promise<productsControllerFindAllResponse> => {
  
  const res = await fetch(getProductsControllerFindAllUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: productsControllerFindAllResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as productsControllerFindAllResponse
}





export const getProductsControllerFindAllQueryKey = () => {
    return [
    `/api/products`
    ] as const;
    }

    
export const getProductsControllerFindAllQueryOptions = <TData = Awaited<ReturnType<typeof productsControllerFindAll>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof productsControllerFindAll>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getProductsControllerFindAllQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof productsControllerFindAll>>> = ({ signal }) => productsControllerFindAll({ signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof productsControllerFindAll>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ProductsControllerFindAllQueryResult = NonNullable<Awaited<ReturnType<typeof productsControllerFindAll>>>
export type ProductsControllerFindAllQueryError = unknown


export function useProductsControllerFindAll<TData = Awaited<ReturnType<typeof productsControllerFindAll>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof productsControllerFindAll>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof productsControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof productsControllerFindAll>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useProductsControllerFindAll<TData = Awaited<ReturnType<typeof productsControllerFindAll>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof productsControllerFindAll>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof productsControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof productsControllerFindAll>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useProductsControllerFindAll<TData = Awaited<ReturnType<typeof productsControllerFindAll>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof productsControllerFindAll>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useProductsControllerFindAll<TData = Awaited<ReturnType<typeof productsControllerFindAll>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof productsControllerFindAll>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getProductsControllerFindAllQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





export type productsControllerFindOneResponse200 = {
  data: void
  status: 200
}
    
export type productsControllerFindOneResponseSuccess = (productsControllerFindOneResponse200) & {
  headers: Headers;
};
;

export type productsControllerFindOneResponse = (productsControllerFindOneResponseSuccess)

export const getProductsControllerFindOneUrl = (id: string,) => {


  

  return `/api/products/${id}`
}

export const productsControllerFindOne = async (id: string, options?: RequestInit): Promise<productsControllerFindOneResponse> => {
  
  const res = await fetch(getProductsControllerFindOneUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: productsControllerFindOneResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as productsControllerFindOneResponse
}





export const getProductsControllerFindOneQueryKey = (id: string,) => {
    return [
    `/api/products/${id}`
    ] as const;
    }

    
export const getProductsControllerFindOneQueryOptions = <TData = Awaited<ReturnType<typeof productsControllerFindOne>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof productsControllerFindOne>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getProductsControllerFindOneQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof productsControllerFindOne>>> = ({ signal }) => productsControllerFindOne(id, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof productsControllerFindOne>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ProductsControllerFindOneQueryResult = NonNullable<Awaited<ReturnType<typeof productsControllerFindOne>>>
export type ProductsControllerFindOneQueryError = unknown


export function useProductsControllerFindOne<TData = Awaited<ReturnType<typeof productsControllerFindOne>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof productsControllerFindOne>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof productsControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof productsControllerFindOne>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useProductsControllerFindOne<TData = Awaited<ReturnType<typeof productsControllerFindOne>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof productsControllerFindOne>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof productsControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof productsControllerFindOne>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useProductsControllerFindOne<TData = Awaited<ReturnType<typeof productsControllerFindOne>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof productsControllerFindOne>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useProductsControllerFindOne<TData = Awaited<ReturnType<typeof productsControllerFindOne>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof productsControllerFindOne>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getProductsControllerFindOneQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





export type productsControllerUpdateResponse200 = {
  data: void
  status: 200
}
    
export type productsControllerUpdateResponseSuccess = (productsControllerUpdateResponse200) & {
  headers: Headers;
};
;

export type productsControllerUpdateResponse = (productsControllerUpdateResponseSuccess)

export const getProductsControllerUpdateUrl = (id: string,) => {


  

  return `/api/products/${id}`
}

export const productsControllerUpdate = async (id: string,
    updateProductDto: UpdateProductDto, options?: RequestInit): Promise<productsControllerUpdateResponse> => {
  
  const res = await fetch(getProductsControllerUpdateUrl(id),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateProductDto,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: productsControllerUpdateResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as productsControllerUpdateResponse
}




export const getProductsControllerUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof productsControllerUpdate>>, TError,{id: string;data: UpdateProductDto}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof productsControllerUpdate>>, TError,{id: string;data: UpdateProductDto}, TContext> => {

const mutationKey = ['productsControllerUpdate'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof productsControllerUpdate>>, {id: string;data: UpdateProductDto}> = (props) => {
          const {id,data} = props ?? {};

          return  productsControllerUpdate(id,data,fetchOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type ProductsControllerUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof productsControllerUpdate>>>
    export type ProductsControllerUpdateMutationBody = UpdateProductDto
    export type ProductsControllerUpdateMutationError = unknown

    export const useProductsControllerUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof productsControllerUpdate>>, TError,{id: string;data: UpdateProductDto}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof productsControllerUpdate>>,
        TError,
        {id: string;data: UpdateProductDto},
        TContext
      > => {
      return useMutation(getProductsControllerUpdateMutationOptions(options), queryClient);
    }
    
export type productsControllerRemoveResponse200 = {
  data: void
  status: 200
}
    
export type productsControllerRemoveResponseSuccess = (productsControllerRemoveResponse200) & {
  headers: Headers;
};
;

export type productsControllerRemoveResponse = (productsControllerRemoveResponseSuccess)

export const getProductsControllerRemoveUrl = (id: string,) => {


  

  return `/api/products/${id}`
}

export const productsControllerRemove = async (id: string, options?: RequestInit): Promise<productsControllerRemoveResponse> => {
  
  const res = await fetch(getProductsControllerRemoveUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: productsControllerRemoveResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as productsControllerRemoveResponse
}




export const getProductsControllerRemoveMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof productsControllerRemove>>, TError,{id: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof productsControllerRemove>>, TError,{id: string}, TContext> => {

const mutationKey = ['productsControllerRemove'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof productsControllerRemove>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  productsControllerRemove(id,fetchOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type ProductsControllerRemoveMutationResult = NonNullable<Awaited<ReturnType<typeof productsControllerRemove>>>
    
    export type ProductsControllerRemoveMutationError = unknown

    export const useProductsControllerRemove = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof productsControllerRemove>>, TError,{id: string}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof productsControllerRemove>>,
        TError,
        {id: string},
        TContext
      > => {
      return useMutation(getProductsControllerRemoveMutationOptions(options), queryClient);
    }
    
export type authControllerLoginResponse201 = {
  data: void
  status: 201
}
    
export type authControllerLoginResponseSuccess = (authControllerLoginResponse201) & {
  headers: Headers;
};
;

export type authControllerLoginResponse = (authControllerLoginResponseSuccess)

export const getAuthControllerLoginUrl = () => {


  

  return `/api/auth/login`
}

export const authControllerLogin = async ( options?: RequestInit): Promise<authControllerLoginResponse> => {
  
  const res = await fetch(getAuthControllerLoginUrl(),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: authControllerLoginResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as authControllerLoginResponse
}




export const getAuthControllerLoginMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerLogin>>, TError,void, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof authControllerLogin>>, TError,void, TContext> => {

const mutationKey = ['authControllerLogin'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerLogin>>, void> = () => {
          

          return  authControllerLogin(fetchOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerLoginMutationResult = NonNullable<Awaited<ReturnType<typeof authControllerLogin>>>
    
    export type AuthControllerLoginMutationError = unknown

    export const useAuthControllerLogin = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerLogin>>, TError,void, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authControllerLogin>>,
        TError,
        void,
        TContext
      > => {
      return useMutation(getAuthControllerLoginMutationOptions(options), queryClient);
    }
    
export type authControllerSendOtpResponse201 = {
  data: void
  status: 201
}
    
export type authControllerSendOtpResponseSuccess = (authControllerSendOtpResponse201) & {
  headers: Headers;
};
;

export type authControllerSendOtpResponse = (authControllerSendOtpResponseSuccess)

export const getAuthControllerSendOtpUrl = () => {


  

  return `/api/auth/otp/send`
}

export const authControllerSendOtp = async ( options?: RequestInit): Promise<authControllerSendOtpResponse> => {
  
  const res = await fetch(getAuthControllerSendOtpUrl(),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: authControllerSendOtpResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as authControllerSendOtpResponse
}




export const getAuthControllerSendOtpMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerSendOtp>>, TError,void, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof authControllerSendOtp>>, TError,void, TContext> => {

const mutationKey = ['authControllerSendOtp'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerSendOtp>>, void> = () => {
          

          return  authControllerSendOtp(fetchOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerSendOtpMutationResult = NonNullable<Awaited<ReturnType<typeof authControllerSendOtp>>>
    
    export type AuthControllerSendOtpMutationError = unknown

    export const useAuthControllerSendOtp = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerSendOtp>>, TError,void, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authControllerSendOtp>>,
        TError,
        void,
        TContext
      > => {
      return useMutation(getAuthControllerSendOtpMutationOptions(options), queryClient);
    }
    
export type authControllerVerifyOtpResponse201 = {
  data: AuthControllerVerifyOtp201
  status: 201
}
    
export type authControllerVerifyOtpResponseSuccess = (authControllerVerifyOtpResponse201) & {
  headers: Headers;
};
;

export type authControllerVerifyOtpResponse = (authControllerVerifyOtpResponseSuccess)

export const getAuthControllerVerifyOtpUrl = () => {


  

  return `/api/auth/otp/verify`
}

export const authControllerVerifyOtp = async ( options?: RequestInit): Promise<authControllerVerifyOtpResponse> => {
  
  const res = await fetch(getAuthControllerVerifyOtpUrl(),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: authControllerVerifyOtpResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as authControllerVerifyOtpResponse
}




export const getAuthControllerVerifyOtpMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerVerifyOtp>>, TError,void, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof authControllerVerifyOtp>>, TError,void, TContext> => {

const mutationKey = ['authControllerVerifyOtp'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerVerifyOtp>>, void> = () => {
          

          return  authControllerVerifyOtp(fetchOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerVerifyOtpMutationResult = NonNullable<Awaited<ReturnType<typeof authControllerVerifyOtp>>>
    
    export type AuthControllerVerifyOtpMutationError = unknown

    export const useAuthControllerVerifyOtp = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerVerifyOtp>>, TError,void, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authControllerVerifyOtp>>,
        TError,
        void,
        TContext
      > => {
      return useMutation(getAuthControllerVerifyOtpMutationOptions(options), queryClient);
    }
    
export type authControllerRegisterResponse201 = {
  data: void
  status: 201
}
    
export type authControllerRegisterResponseSuccess = (authControllerRegisterResponse201) & {
  headers: Headers;
};
;

export type authControllerRegisterResponse = (authControllerRegisterResponseSuccess)

export const getAuthControllerRegisterUrl = () => {


  

  return `/api/auth/register`
}

export const authControllerRegister = async ( options?: RequestInit): Promise<authControllerRegisterResponse> => {
  
  const res = await fetch(getAuthControllerRegisterUrl(),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: authControllerRegisterResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as authControllerRegisterResponse
}




export const getAuthControllerRegisterMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerRegister>>, TError,void, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof authControllerRegister>>, TError,void, TContext> => {

const mutationKey = ['authControllerRegister'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerRegister>>, void> = () => {
          

          return  authControllerRegister(fetchOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerRegisterMutationResult = NonNullable<Awaited<ReturnType<typeof authControllerRegister>>>
    
    export type AuthControllerRegisterMutationError = unknown

    export const useAuthControllerRegister = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerRegister>>, TError,void, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authControllerRegister>>,
        TError,
        void,
        TContext
      > => {
      return useMutation(getAuthControllerRegisterMutationOptions(options), queryClient);
    }
    
export type authControllerLoginTelegramResponse201 = {
  data: void
  status: 201
}
    
export type authControllerLoginTelegramResponseSuccess = (authControllerLoginTelegramResponse201) & {
  headers: Headers;
};
;

export type authControllerLoginTelegramResponse = (authControllerLoginTelegramResponseSuccess)

export const getAuthControllerLoginTelegramUrl = () => {


  

  return `/api/auth/telegram`
}

export const authControllerLoginTelegram = async (telegramLoginDto: TelegramLoginDto, options?: RequestInit): Promise<authControllerLoginTelegramResponse> => {
  
  const res = await fetch(getAuthControllerLoginTelegramUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      telegramLoginDto,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: authControllerLoginTelegramResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as authControllerLoginTelegramResponse
}




export const getAuthControllerLoginTelegramMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerLoginTelegram>>, TError,{data: TelegramLoginDto}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof authControllerLoginTelegram>>, TError,{data: TelegramLoginDto}, TContext> => {

const mutationKey = ['authControllerLoginTelegram'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerLoginTelegram>>, {data: TelegramLoginDto}> = (props) => {
          const {data} = props ?? {};

          return  authControllerLoginTelegram(data,fetchOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerLoginTelegramMutationResult = NonNullable<Awaited<ReturnType<typeof authControllerLoginTelegram>>>
    export type AuthControllerLoginTelegramMutationBody = TelegramLoginDto
    export type AuthControllerLoginTelegramMutationError = unknown

    export const useAuthControllerLoginTelegram = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerLoginTelegram>>, TError,{data: TelegramLoginDto}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authControllerLoginTelegram>>,
        TError,
        {data: TelegramLoginDto},
        TContext
      > => {
      return useMutation(getAuthControllerLoginTelegramMutationOptions(options), queryClient);
    }
    
export type usersControllerCreateResponse201 = {
  data: string
  status: 201
}
    
export type usersControllerCreateResponseSuccess = (usersControllerCreateResponse201) & {
  headers: Headers;
};
;

export type usersControllerCreateResponse = (usersControllerCreateResponseSuccess)

export const getUsersControllerCreateUrl = () => {


  

  return `/api/users`
}

export const usersControllerCreate = async (createUserDto: CreateUserDto, options?: RequestInit): Promise<usersControllerCreateResponse> => {
  
  const res = await fetch(getUsersControllerCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createUserDto,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: usersControllerCreateResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as usersControllerCreateResponse
}




export const getUsersControllerCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersControllerCreate>>, TError,{data: CreateUserDto}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof usersControllerCreate>>, TError,{data: CreateUserDto}, TContext> => {

const mutationKey = ['usersControllerCreate'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersControllerCreate>>, {data: CreateUserDto}> = (props) => {
          const {data} = props ?? {};

          return  usersControllerCreate(data,fetchOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UsersControllerCreateMutationResult = NonNullable<Awaited<ReturnType<typeof usersControllerCreate>>>
    export type UsersControllerCreateMutationBody = CreateUserDto
    export type UsersControllerCreateMutationError = unknown

    export const useUsersControllerCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersControllerCreate>>, TError,{data: CreateUserDto}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof usersControllerCreate>>,
        TError,
        {data: CreateUserDto},
        TContext
      > => {
      return useMutation(getUsersControllerCreateMutationOptions(options), queryClient);
    }
    
export type usersControllerFindAllResponse200 = {
  data: void
  status: 200
}
    
export type usersControllerFindAllResponseSuccess = (usersControllerFindAllResponse200) & {
  headers: Headers;
};
;

export type usersControllerFindAllResponse = (usersControllerFindAllResponseSuccess)

export const getUsersControllerFindAllUrl = () => {


  

  return `/api/users`
}

export const usersControllerFindAll = async ( options?: RequestInit): Promise<usersControllerFindAllResponse> => {
  
  const res = await fetch(getUsersControllerFindAllUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: usersControllerFindAllResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as usersControllerFindAllResponse
}





export const getUsersControllerFindAllQueryKey = () => {
    return [
    `/api/users`
    ] as const;
    }

    
export const getUsersControllerFindAllQueryOptions = <TData = Awaited<ReturnType<typeof usersControllerFindAll>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerFindAll>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getUsersControllerFindAllQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof usersControllerFindAll>>> = ({ signal }) => usersControllerFindAll({ signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof usersControllerFindAll>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type UsersControllerFindAllQueryResult = NonNullable<Awaited<ReturnType<typeof usersControllerFindAll>>>
export type UsersControllerFindAllQueryError = unknown


export function useUsersControllerFindAll<TData = Awaited<ReturnType<typeof usersControllerFindAll>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerFindAll>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof usersControllerFindAll>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsersControllerFindAll<TData = Awaited<ReturnType<typeof usersControllerFindAll>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerFindAll>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof usersControllerFindAll>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsersControllerFindAll<TData = Awaited<ReturnType<typeof usersControllerFindAll>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerFindAll>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useUsersControllerFindAll<TData = Awaited<ReturnType<typeof usersControllerFindAll>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerFindAll>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUsersControllerFindAllQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





export type usersControllerGetProfileResponse200 = {
  data: void
  status: 200
}
    
export type usersControllerGetProfileResponseSuccess = (usersControllerGetProfileResponse200) & {
  headers: Headers;
};
;

export type usersControllerGetProfileResponse = (usersControllerGetProfileResponseSuccess)

export const getUsersControllerGetProfileUrl = () => {


  

  return `/api/users/me`
}

export const usersControllerGetProfile = async ( options?: RequestInit): Promise<usersControllerGetProfileResponse> => {
  
  const res = await fetch(getUsersControllerGetProfileUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: usersControllerGetProfileResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as usersControllerGetProfileResponse
}





export const getUsersControllerGetProfileQueryKey = () => {
    return [
    `/api/users/me`
    ] as const;
    }

    
export const getUsersControllerGetProfileQueryOptions = <TData = Awaited<ReturnType<typeof usersControllerGetProfile>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerGetProfile>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getUsersControllerGetProfileQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof usersControllerGetProfile>>> = ({ signal }) => usersControllerGetProfile({ signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof usersControllerGetProfile>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type UsersControllerGetProfileQueryResult = NonNullable<Awaited<ReturnType<typeof usersControllerGetProfile>>>
export type UsersControllerGetProfileQueryError = unknown


export function useUsersControllerGetProfile<TData = Awaited<ReturnType<typeof usersControllerGetProfile>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerGetProfile>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersControllerGetProfile>>,
          TError,
          Awaited<ReturnType<typeof usersControllerGetProfile>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsersControllerGetProfile<TData = Awaited<ReturnType<typeof usersControllerGetProfile>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerGetProfile>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersControllerGetProfile>>,
          TError,
          Awaited<ReturnType<typeof usersControllerGetProfile>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsersControllerGetProfile<TData = Awaited<ReturnType<typeof usersControllerGetProfile>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerGetProfile>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useUsersControllerGetProfile<TData = Awaited<ReturnType<typeof usersControllerGetProfile>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerGetProfile>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUsersControllerGetProfileQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





export type usersControllerUpdateProfileResponse200 = {
  data: void
  status: 200
}
    
export type usersControllerUpdateProfileResponseSuccess = (usersControllerUpdateProfileResponse200) & {
  headers: Headers;
};
;

export type usersControllerUpdateProfileResponse = (usersControllerUpdateProfileResponseSuccess)

export const getUsersControllerUpdateProfileUrl = () => {


  

  return `/api/users/me`
}

export const usersControllerUpdateProfile = async (updateUserDto: UpdateUserDto, options?: RequestInit): Promise<usersControllerUpdateProfileResponse> => {
  
  const res = await fetch(getUsersControllerUpdateProfileUrl(),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateUserDto,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: usersControllerUpdateProfileResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as usersControllerUpdateProfileResponse
}




export const getUsersControllerUpdateProfileMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersControllerUpdateProfile>>, TError,{data: UpdateUserDto}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof usersControllerUpdateProfile>>, TError,{data: UpdateUserDto}, TContext> => {

const mutationKey = ['usersControllerUpdateProfile'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersControllerUpdateProfile>>, {data: UpdateUserDto}> = (props) => {
          const {data} = props ?? {};

          return  usersControllerUpdateProfile(data,fetchOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UsersControllerUpdateProfileMutationResult = NonNullable<Awaited<ReturnType<typeof usersControllerUpdateProfile>>>
    export type UsersControllerUpdateProfileMutationBody = UpdateUserDto
    export type UsersControllerUpdateProfileMutationError = unknown

    export const useUsersControllerUpdateProfile = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersControllerUpdateProfile>>, TError,{data: UpdateUserDto}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof usersControllerUpdateProfile>>,
        TError,
        {data: UpdateUserDto},
        TContext
      > => {
      return useMutation(getUsersControllerUpdateProfileMutationOptions(options), queryClient);
    }
    
export type usersControllerFindOneResponse200 = {
  data: void
  status: 200
}
    
export type usersControllerFindOneResponseSuccess = (usersControllerFindOneResponse200) & {
  headers: Headers;
};
;

export type usersControllerFindOneResponse = (usersControllerFindOneResponseSuccess)

export const getUsersControllerFindOneUrl = (id: string,) => {


  

  return `/api/users/${id}`
}

export const usersControllerFindOne = async (id: string, options?: RequestInit): Promise<usersControllerFindOneResponse> => {
  
  const res = await fetch(getUsersControllerFindOneUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: usersControllerFindOneResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as usersControllerFindOneResponse
}





export const getUsersControllerFindOneQueryKey = (id: string,) => {
    return [
    `/api/users/${id}`
    ] as const;
    }

    
export const getUsersControllerFindOneQueryOptions = <TData = Awaited<ReturnType<typeof usersControllerFindOne>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerFindOne>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getUsersControllerFindOneQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof usersControllerFindOne>>> = ({ signal }) => usersControllerFindOne(id, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof usersControllerFindOne>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type UsersControllerFindOneQueryResult = NonNullable<Awaited<ReturnType<typeof usersControllerFindOne>>>
export type UsersControllerFindOneQueryError = unknown


export function useUsersControllerFindOne<TData = Awaited<ReturnType<typeof usersControllerFindOne>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerFindOne>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof usersControllerFindOne>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsersControllerFindOne<TData = Awaited<ReturnType<typeof usersControllerFindOne>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerFindOne>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof usersControllerFindOne>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsersControllerFindOne<TData = Awaited<ReturnType<typeof usersControllerFindOne>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerFindOne>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useUsersControllerFindOne<TData = Awaited<ReturnType<typeof usersControllerFindOne>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerFindOne>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUsersControllerFindOneQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





export type usersControllerUpdateResponse200 = {
  data: void
  status: 200
}
    
export type usersControllerUpdateResponseSuccess = (usersControllerUpdateResponse200) & {
  headers: Headers;
};
;

export type usersControllerUpdateResponse = (usersControllerUpdateResponseSuccess)

export const getUsersControllerUpdateUrl = (id: string,) => {


  

  return `/api/users/${id}`
}

export const usersControllerUpdate = async (id: string,
    updateUserDto: UpdateUserDto, options?: RequestInit): Promise<usersControllerUpdateResponse> => {
  
  const res = await fetch(getUsersControllerUpdateUrl(id),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateUserDto,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: usersControllerUpdateResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as usersControllerUpdateResponse
}




export const getUsersControllerUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersControllerUpdate>>, TError,{id: string;data: UpdateUserDto}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof usersControllerUpdate>>, TError,{id: string;data: UpdateUserDto}, TContext> => {

const mutationKey = ['usersControllerUpdate'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersControllerUpdate>>, {id: string;data: UpdateUserDto}> = (props) => {
          const {id,data} = props ?? {};

          return  usersControllerUpdate(id,data,fetchOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UsersControllerUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof usersControllerUpdate>>>
    export type UsersControllerUpdateMutationBody = UpdateUserDto
    export type UsersControllerUpdateMutationError = unknown

    export const useUsersControllerUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersControllerUpdate>>, TError,{id: string;data: UpdateUserDto}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof usersControllerUpdate>>,
        TError,
        {id: string;data: UpdateUserDto},
        TContext
      > => {
      return useMutation(getUsersControllerUpdateMutationOptions(options), queryClient);
    }
    
export type usersControllerRemoveResponse200 = {
  data: void
  status: 200
}
    
export type usersControllerRemoveResponseSuccess = (usersControllerRemoveResponse200) & {
  headers: Headers;
};
;

export type usersControllerRemoveResponse = (usersControllerRemoveResponseSuccess)

export const getUsersControllerRemoveUrl = (id: string,) => {


  

  return `/api/users/${id}`
}

export const usersControllerRemove = async (id: string, options?: RequestInit): Promise<usersControllerRemoveResponse> => {
  
  const res = await fetch(getUsersControllerRemoveUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: usersControllerRemoveResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as usersControllerRemoveResponse
}




export const getUsersControllerRemoveMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersControllerRemove>>, TError,{id: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof usersControllerRemove>>, TError,{id: string}, TContext> => {

const mutationKey = ['usersControllerRemove'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersControllerRemove>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  usersControllerRemove(id,fetchOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UsersControllerRemoveMutationResult = NonNullable<Awaited<ReturnType<typeof usersControllerRemove>>>
    
    export type UsersControllerRemoveMutationError = unknown

    export const useUsersControllerRemove = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersControllerRemove>>, TError,{id: string}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof usersControllerRemove>>,
        TError,
        {id: string},
        TContext
      > => {
      return useMutation(getUsersControllerRemoveMutationOptions(options), queryClient);
    }
    
export type ordersControllerCreateResponse201 = {
  data: OrdersControllerCreate201
  status: 201
}
    
export type ordersControllerCreateResponseSuccess = (ordersControllerCreateResponse201) & {
  headers: Headers;
};
;

export type ordersControllerCreateResponse = (ordersControllerCreateResponseSuccess)

export const getOrdersControllerCreateUrl = () => {


  

  return `/api/orders`
}

export const ordersControllerCreate = async (createOrderDto: CreateOrderDto, options?: RequestInit): Promise<ordersControllerCreateResponse> => {
  
  const res = await fetch(getOrdersControllerCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createOrderDto,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: ordersControllerCreateResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as ordersControllerCreateResponse
}




export const getOrdersControllerCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ordersControllerCreate>>, TError,{data: CreateOrderDto}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof ordersControllerCreate>>, TError,{data: CreateOrderDto}, TContext> => {

const mutationKey = ['ordersControllerCreate'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ordersControllerCreate>>, {data: CreateOrderDto}> = (props) => {
          const {data} = props ?? {};

          return  ordersControllerCreate(data,fetchOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type OrdersControllerCreateMutationResult = NonNullable<Awaited<ReturnType<typeof ordersControllerCreate>>>
    export type OrdersControllerCreateMutationBody = CreateOrderDto
    export type OrdersControllerCreateMutationError = unknown

    export const useOrdersControllerCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ordersControllerCreate>>, TError,{data: CreateOrderDto}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ordersControllerCreate>>,
        TError,
        {data: CreateOrderDto},
        TContext
      > => {
      return useMutation(getOrdersControllerCreateMutationOptions(options), queryClient);
    }
    
export type ordersControllerFindAllResponse200 = {
  data: OrdersControllerFindAll200Item[]
  status: 200
}
    
export type ordersControllerFindAllResponseSuccess = (ordersControllerFindAllResponse200) & {
  headers: Headers;
};
;

export type ordersControllerFindAllResponse = (ordersControllerFindAllResponseSuccess)

export const getOrdersControllerFindAllUrl = (params: OrdersControllerFindAllParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/orders?${stringifiedParams}` : `/api/orders`
}

export const ordersControllerFindAll = async (params: OrdersControllerFindAllParams, options?: RequestInit): Promise<ordersControllerFindAllResponse> => {
  
  const res = await fetch(getOrdersControllerFindAllUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: ordersControllerFindAllResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as ordersControllerFindAllResponse
}





export const getOrdersControllerFindAllQueryKey = (params?: OrdersControllerFindAllParams,) => {
    return [
    `/api/orders`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getOrdersControllerFindAllQueryOptions = <TData = Awaited<ReturnType<typeof ordersControllerFindAll>>, TError = unknown>(params: OrdersControllerFindAllParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ordersControllerFindAll>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getOrdersControllerFindAllQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof ordersControllerFindAll>>> = ({ signal }) => ordersControllerFindAll(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof ordersControllerFindAll>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type OrdersControllerFindAllQueryResult = NonNullable<Awaited<ReturnType<typeof ordersControllerFindAll>>>
export type OrdersControllerFindAllQueryError = unknown


export function useOrdersControllerFindAll<TData = Awaited<ReturnType<typeof ordersControllerFindAll>>, TError = unknown>(
 params: OrdersControllerFindAllParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof ordersControllerFindAll>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof ordersControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof ordersControllerFindAll>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOrdersControllerFindAll<TData = Awaited<ReturnType<typeof ordersControllerFindAll>>, TError = unknown>(
 params: OrdersControllerFindAllParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ordersControllerFindAll>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof ordersControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof ordersControllerFindAll>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOrdersControllerFindAll<TData = Awaited<ReturnType<typeof ordersControllerFindAll>>, TError = unknown>(
 params: OrdersControllerFindAllParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ordersControllerFindAll>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useOrdersControllerFindAll<TData = Awaited<ReturnType<typeof ordersControllerFindAll>>, TError = unknown>(
 params: OrdersControllerFindAllParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ordersControllerFindAll>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getOrdersControllerFindAllQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





export type ordersControllerFindOneResponse200 = {
  data: void
  status: 200
}
    
export type ordersControllerFindOneResponseSuccess = (ordersControllerFindOneResponse200) & {
  headers: Headers;
};
;

export type ordersControllerFindOneResponse = (ordersControllerFindOneResponseSuccess)

export const getOrdersControllerFindOneUrl = (id: string,) => {


  

  return `/api/orders/${id}`
}

export const ordersControllerFindOne = async (id: string, options?: RequestInit): Promise<ordersControllerFindOneResponse> => {
  
  const res = await fetch(getOrdersControllerFindOneUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: ordersControllerFindOneResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as ordersControllerFindOneResponse
}





export const getOrdersControllerFindOneQueryKey = (id: string,) => {
    return [
    `/api/orders/${id}`
    ] as const;
    }

    
export const getOrdersControllerFindOneQueryOptions = <TData = Awaited<ReturnType<typeof ordersControllerFindOne>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ordersControllerFindOne>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getOrdersControllerFindOneQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof ordersControllerFindOne>>> = ({ signal }) => ordersControllerFindOne(id, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof ordersControllerFindOne>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type OrdersControllerFindOneQueryResult = NonNullable<Awaited<ReturnType<typeof ordersControllerFindOne>>>
export type OrdersControllerFindOneQueryError = unknown


export function useOrdersControllerFindOne<TData = Awaited<ReturnType<typeof ordersControllerFindOne>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof ordersControllerFindOne>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof ordersControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof ordersControllerFindOne>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOrdersControllerFindOne<TData = Awaited<ReturnType<typeof ordersControllerFindOne>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ordersControllerFindOne>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof ordersControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof ordersControllerFindOne>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOrdersControllerFindOne<TData = Awaited<ReturnType<typeof ordersControllerFindOne>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ordersControllerFindOne>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useOrdersControllerFindOne<TData = Awaited<ReturnType<typeof ordersControllerFindOne>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ordersControllerFindOne>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getOrdersControllerFindOneQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





export type ordersControllerUpdateResponse200 = {
  data: OrdersControllerUpdate200
  status: 200
}
    
export type ordersControllerUpdateResponseSuccess = (ordersControllerUpdateResponse200) & {
  headers: Headers;
};
;

export type ordersControllerUpdateResponse = (ordersControllerUpdateResponseSuccess)

export const getOrdersControllerUpdateUrl = (id: string,) => {


  

  return `/api/orders/${id}`
}

export const ordersControllerUpdate = async (id: string,
    updateOrderDto: UpdateOrderDto, options?: RequestInit): Promise<ordersControllerUpdateResponse> => {
  
  const res = await fetch(getOrdersControllerUpdateUrl(id),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateOrderDto,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: ordersControllerUpdateResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as ordersControllerUpdateResponse
}




export const getOrdersControllerUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ordersControllerUpdate>>, TError,{id: string;data: UpdateOrderDto}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof ordersControllerUpdate>>, TError,{id: string;data: UpdateOrderDto}, TContext> => {

const mutationKey = ['ordersControllerUpdate'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ordersControllerUpdate>>, {id: string;data: UpdateOrderDto}> = (props) => {
          const {id,data} = props ?? {};

          return  ordersControllerUpdate(id,data,fetchOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type OrdersControllerUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof ordersControllerUpdate>>>
    export type OrdersControllerUpdateMutationBody = UpdateOrderDto
    export type OrdersControllerUpdateMutationError = unknown

    export const useOrdersControllerUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ordersControllerUpdate>>, TError,{id: string;data: UpdateOrderDto}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ordersControllerUpdate>>,
        TError,
        {id: string;data: UpdateOrderDto},
        TContext
      > => {
      return useMutation(getOrdersControllerUpdateMutationOptions(options), queryClient);
    }
    
export type ordersControllerRemoveResponse200 = {
  data: void
  status: 200
}
    
export type ordersControllerRemoveResponseSuccess = (ordersControllerRemoveResponse200) & {
  headers: Headers;
};
;

export type ordersControllerRemoveResponse = (ordersControllerRemoveResponseSuccess)

export const getOrdersControllerRemoveUrl = (id: string,) => {


  

  return `/api/orders/${id}`
}

export const ordersControllerRemove = async (id: string, options?: RequestInit): Promise<ordersControllerRemoveResponse> => {
  
  const res = await fetch(getOrdersControllerRemoveUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: ordersControllerRemoveResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as ordersControllerRemoveResponse
}




export const getOrdersControllerRemoveMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ordersControllerRemove>>, TError,{id: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof ordersControllerRemove>>, TError,{id: string}, TContext> => {

const mutationKey = ['ordersControllerRemove'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ordersControllerRemove>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  ordersControllerRemove(id,fetchOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type OrdersControllerRemoveMutationResult = NonNullable<Awaited<ReturnType<typeof ordersControllerRemove>>>
    
    export type OrdersControllerRemoveMutationError = unknown

    export const useOrdersControllerRemove = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ordersControllerRemove>>, TError,{id: string}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ordersControllerRemove>>,
        TError,
        {id: string},
        TContext
      > => {
      return useMutation(getOrdersControllerRemoveMutationOptions(options), queryClient);
    }
    
export type filesControllerUploadFileResponse201 = {
  data: void
  status: 201
}
    
export type filesControllerUploadFileResponseSuccess = (filesControllerUploadFileResponse201) & {
  headers: Headers;
};
;

export type filesControllerUploadFileResponse = (filesControllerUploadFileResponseSuccess)

export const getFilesControllerUploadFileUrl = () => {


  

  return `/api/upload`
}

export const filesControllerUploadFile = async ( options?: RequestInit): Promise<filesControllerUploadFileResponse> => {
  
  const res = await fetch(getFilesControllerUploadFileUrl(),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: filesControllerUploadFileResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as filesControllerUploadFileResponse
}




export const getFilesControllerUploadFileMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof filesControllerUploadFile>>, TError,void, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof filesControllerUploadFile>>, TError,void, TContext> => {

const mutationKey = ['filesControllerUploadFile'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof filesControllerUploadFile>>, void> = () => {
          

          return  filesControllerUploadFile(fetchOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type FilesControllerUploadFileMutationResult = NonNullable<Awaited<ReturnType<typeof filesControllerUploadFile>>>
    
    export type FilesControllerUploadFileMutationError = unknown

    export const useFilesControllerUploadFile = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof filesControllerUploadFile>>, TError,void, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof filesControllerUploadFile>>,
        TError,
        void,
        TContext
      > => {
      return useMutation(getFilesControllerUploadFileMutationOptions(options), queryClient);
    }
    
export type settingsControllerFindAllResponse200 = {
  data: void
  status: 200
}
    
export type settingsControllerFindAllResponseSuccess = (settingsControllerFindAllResponse200) & {
  headers: Headers;
};
;

export type settingsControllerFindAllResponse = (settingsControllerFindAllResponseSuccess)

export const getSettingsControllerFindAllUrl = () => {


  

  return `/api/settings`
}

export const settingsControllerFindAll = async ( options?: RequestInit): Promise<settingsControllerFindAllResponse> => {
  
  const res = await fetch(getSettingsControllerFindAllUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: settingsControllerFindAllResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as settingsControllerFindAllResponse
}





export const getSettingsControllerFindAllQueryKey = () => {
    return [
    `/api/settings`
    ] as const;
    }

    
export const getSettingsControllerFindAllQueryOptions = <TData = Awaited<ReturnType<typeof settingsControllerFindAll>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof settingsControllerFindAll>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSettingsControllerFindAllQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof settingsControllerFindAll>>> = ({ signal }) => settingsControllerFindAll({ signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof settingsControllerFindAll>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SettingsControllerFindAllQueryResult = NonNullable<Awaited<ReturnType<typeof settingsControllerFindAll>>>
export type SettingsControllerFindAllQueryError = unknown


export function useSettingsControllerFindAll<TData = Awaited<ReturnType<typeof settingsControllerFindAll>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof settingsControllerFindAll>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof settingsControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof settingsControllerFindAll>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSettingsControllerFindAll<TData = Awaited<ReturnType<typeof settingsControllerFindAll>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof settingsControllerFindAll>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof settingsControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof settingsControllerFindAll>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSettingsControllerFindAll<TData = Awaited<ReturnType<typeof settingsControllerFindAll>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof settingsControllerFindAll>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useSettingsControllerFindAll<TData = Awaited<ReturnType<typeof settingsControllerFindAll>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof settingsControllerFindAll>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSettingsControllerFindAllQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





export type settingsControllerUpdateResponse200 = {
  data: void
  status: 200
}
    
export type settingsControllerUpdateResponseSuccess = (settingsControllerUpdateResponse200) & {
  headers: Headers;
};
;

export type settingsControllerUpdateResponse = (settingsControllerUpdateResponseSuccess)

export const getSettingsControllerUpdateUrl = (key: string,) => {


  

  return `/api/settings/${key}`
}

export const settingsControllerUpdate = async (key: string,
    updateSettingDto: UpdateSettingDto, options?: RequestInit): Promise<settingsControllerUpdateResponse> => {
  
  const res = await fetch(getSettingsControllerUpdateUrl(key),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateSettingDto,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: settingsControllerUpdateResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as settingsControllerUpdateResponse
}




export const getSettingsControllerUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof settingsControllerUpdate>>, TError,{key: string;data: UpdateSettingDto}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof settingsControllerUpdate>>, TError,{key: string;data: UpdateSettingDto}, TContext> => {

const mutationKey = ['settingsControllerUpdate'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof settingsControllerUpdate>>, {key: string;data: UpdateSettingDto}> = (props) => {
          const {key,data} = props ?? {};

          return  settingsControllerUpdate(key,data,fetchOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type SettingsControllerUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof settingsControllerUpdate>>>
    export type SettingsControllerUpdateMutationBody = UpdateSettingDto
    export type SettingsControllerUpdateMutationError = unknown

    export const useSettingsControllerUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof settingsControllerUpdate>>, TError,{key: string;data: UpdateSettingDto}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof settingsControllerUpdate>>,
        TError,
        {key: string;data: UpdateSettingDto},
        TContext
      > => {
      return useMutation(getSettingsControllerUpdateMutationOptions(options), queryClient);
    }
    
export type settingsControllerFindTelegramUsersResponse200 = {
  data: void
  status: 200
}
    
export type settingsControllerFindTelegramUsersResponseSuccess = (settingsControllerFindTelegramUsersResponse200) & {
  headers: Headers;
};
;

export type settingsControllerFindTelegramUsersResponse = (settingsControllerFindTelegramUsersResponseSuccess)

export const getSettingsControllerFindTelegramUsersUrl = () => {


  

  return `/api/settings/telegram-users`
}

export const settingsControllerFindTelegramUsers = async ( options?: RequestInit): Promise<settingsControllerFindTelegramUsersResponse> => {
  
  const res = await fetch(getSettingsControllerFindTelegramUsersUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: settingsControllerFindTelegramUsersResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as settingsControllerFindTelegramUsersResponse
}





export const getSettingsControllerFindTelegramUsersQueryKey = () => {
    return [
    `/api/settings/telegram-users`
    ] as const;
    }

    
export const getSettingsControllerFindTelegramUsersQueryOptions = <TData = Awaited<ReturnType<typeof settingsControllerFindTelegramUsers>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof settingsControllerFindTelegramUsers>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSettingsControllerFindTelegramUsersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof settingsControllerFindTelegramUsers>>> = ({ signal }) => settingsControllerFindTelegramUsers({ signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof settingsControllerFindTelegramUsers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SettingsControllerFindTelegramUsersQueryResult = NonNullable<Awaited<ReturnType<typeof settingsControllerFindTelegramUsers>>>
export type SettingsControllerFindTelegramUsersQueryError = unknown


export function useSettingsControllerFindTelegramUsers<TData = Awaited<ReturnType<typeof settingsControllerFindTelegramUsers>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof settingsControllerFindTelegramUsers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof settingsControllerFindTelegramUsers>>,
          TError,
          Awaited<ReturnType<typeof settingsControllerFindTelegramUsers>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSettingsControllerFindTelegramUsers<TData = Awaited<ReturnType<typeof settingsControllerFindTelegramUsers>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof settingsControllerFindTelegramUsers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof settingsControllerFindTelegramUsers>>,
          TError,
          Awaited<ReturnType<typeof settingsControllerFindTelegramUsers>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSettingsControllerFindTelegramUsers<TData = Awaited<ReturnType<typeof settingsControllerFindTelegramUsers>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof settingsControllerFindTelegramUsers>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useSettingsControllerFindTelegramUsers<TData = Awaited<ReturnType<typeof settingsControllerFindTelegramUsers>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof settingsControllerFindTelegramUsers>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSettingsControllerFindTelegramUsersQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}
